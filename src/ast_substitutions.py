# ast_substitutions.py

"""Performs command substitution directly on a pylatexenc v2.10 AST.

This module takes a parsed LaTeX nodelist (AST) generated by pylatexenc v2.10
and applies substitutions for simple, argument-less \newcommand and
\DeclareMathOperator definitions found within that AST.

It is designed to work around the limitations of pylatexenc v2.10, specifically
the lack of a built-in method to serialize a modified AST back to LaTeX.
The output of this module is the *modified* AST (nodelist), ready for further
processing (e.g., translation to another format).

Functions exported:
    apply_substitutions_iteratively: Orchestrates definition finding and substitution.
"""

from __future__ import annotations

import copy
import logging
import warnings
from typing import Dict, List, Optional, Tuple, Union, TYPE_CHECKING

# --- Dependency Check and Import ---
# We need the specific node types from pylatexenc v2.10's latexwalker
try:
    from pylatexenc.latexwalker import (
        LatexCharsNode, LatexCommentNode, LatexEnvironmentNode, LatexGroupNode,
        LatexMacroNode, LatexMathNode, LatexSpecialsNode, LatexNode
    )
    # Need ParsedMacroArgs for type checking nodeargd if necessary, though direct access is used
    from pylatexenc.macrospec import ParsedMacroArgs

    # Define LatexNodeType alias based on imported LatexNode for type hints
    LatexNodeType = LatexNode

except ImportError:
    # Log critical error and recommend specific version install
    logging.basicConfig(level=logging.CRITICAL, format='%(levelname)s: %(message)s')
    logging.critical(
        "FATAL ERROR: Failed to import pylatexenc.latexwalker/macrospec classes. "
        "Ensure pylatexenc v2.10 is installed (`pip install pylatexenc==2.10`)."
    )
    # Exit if run directly, otherwise calling script should handle if needed
    import sys
    if __name__ == "__main__":
        sys.exit(1)
    # If imported, raise the error to notify the importer
    raise

# --- Constants ---
MAX_SUBSTITUTION_PASSES = 10 # Safety limit for iterative substitution

# Type Alias for clarity - Represents the AST structure in v2.10
V2NodelistType = List[LatexNodeType]

# --- Core Substitution Logic (Adapted from previous versions) ---

def find_definitions_v2(
    node_or_list: Optional[Union[LatexNodeType, V2NodelistType]],
    definitions_dict: Dict[str, V2NodelistType],
    logger: logging.Logger
) -> None:
    """Recursively traverses the AST (list/nodes) to find simple definitions.

    Identifies \newcommand{\cmd}{body} and \DeclareMathOperator{\cmd}{body}
    (without stars or arguments in the defined command) in a pylatexenc v2.10 AST,
    accounting for the specific parsing behavior observed in v2.10.

    Args:
        node_or_list: The current node or list of nodes being traversed.
        definitions_dict: A dictionary where found definitions are stored
                          (macro_name_str -> list_of_body_nodes). This dict
                          is modified in place.
        logger: A logging.Logger instance for outputting messages.
    """
    if node_or_list is None:
        return

    if isinstance(node_or_list, list): # Operate on Python lists
        for node in node_or_list:
            find_definitions_v2(node, definitions_dict, logger)
        return

    # Only process nodes, not lists from here
    node = node_or_list
    if not isinstance(node, LatexNode):
         logger.warning(f"Unexpected item type {type(node)} in AST traversal. Skipping.")
         return

    # Check for \newcommand or \DeclareMathOperator
    if node.isNodeType(LatexMacroNode) and node.macroname in ('newcommand', 'DeclareMathOperator'):
        cmd_arg_group: Optional[LatexNodeType] = None
        body_arg_group: Optional[LatexNodeType] = None
        is_simple_definition = False
        processed_node_flag = False # Flag to avoid redundant recursion later

        try:
            # Initial check for nodeargd and argnlist
            if node.nodeargd is None or not hasattr(node.nodeargd, 'argnlist'):
                logger.debug(f"SKIP Definition: \\{node.macroname} at pos {node.pos}. Reason: "
                             f"No arguments found or 'argnlist' missing.")
                processed_node_flag = True # Handled (as skipped)

            else:
                argspec_str = getattr(node.nodeargd, 'argspec', None)
                arglist = node.nodeargd.argnlist
                num_args_found = len(arglist)

                # --- Refined check for SIMPLE \DeclareMathOperator (no *) ---
                if node.macroname == 'DeclareMathOperator':
                    processed_node_flag = True # Mark as handled
                    if argspec_str == '*{{' and num_args_found == 3 and arglist[0] is None:
                        cmd_arg_group = arglist[1]
                        body_arg_group = arglist[2]
                        is_simple_definition = True
                    else:
                        star_repr = arglist[0].latex_verbatim() if arglist and arglist[0] else 'None'
                        logger.debug(f"SKIP Definition: \\{node.macroname} at pos {node.pos}. Reason: "
                                     f"Not simple (no-star) pattern. Args={num_args_found}, "
                                     f"spec='{argspec_str}', star='{star_repr}'.")

                # --- Refined check for SIMPLE \newcommand (no *, no [...]) ---
                elif node.macroname == 'newcommand':
                     processed_node_flag = True # Mark as handled
                     if argspec_str == '*{[[{' and num_args_found == 5 and \
                        arglist[0] is None and arglist[2] is None and arglist[3] is None:
                         cmd_arg_group = arglist[1]
                         body_arg_group = arglist[4]
                         is_simple_definition = True
                     else:
                        reason = f"Not simple (no-star, no-opt-args) pattern. Args={num_args_found}, spec='{argspec_str}'."
                        if arglist:
                             reason += f" star='{arglist[0].latex_verbatim() if arglist[0] else 'None'}'"
                             if num_args_found > 2: reason += f" opt1='{arglist[2].latex_verbatim() if arglist[2] else 'None'}'"
                             if num_args_found > 3: reason += f" opt2='{arglist[3].latex_verbatim() if arglist[3] else 'None'}'"
                        logger.debug(f"SKIP Definition: \\{node.macroname} at pos {node.pos}. Reason: {reason}")

            # --- If tentatively simple, perform final checks and extraction ---
            if is_simple_definition:
                # Ensure the identified args are actually groups
                if not cmd_arg_group or not cmd_arg_group.isNodeType(LatexGroupNode) or \
                   not body_arg_group or not body_arg_group.isNodeType(LatexGroupNode):
                    logger.debug(f"SKIP Definition: \\{node.macroname} at pos {node.pos}. Reason: "
                                 f"Identified command/body args were not simple groups {{...}}. Found types: "
                                 f"{type(cmd_arg_group).__name__}, {type(body_arg_group).__name__}")
                    is_simple_definition = False # Failed final check
                else:
                    cmd_arg_nodes = cmd_arg_group.nodelist
                    body_nodelist = body_arg_group.nodelist
                    command_name: Optional[str] = None

                    if cmd_arg_nodes and len(cmd_arg_nodes) == 1 and cmd_arg_nodes[0].isNodeType(LatexMacroNode):
                        command_name = '\\' + cmd_arg_nodes[0].macroname
                    else:
                        logger.debug(f"SKIP Definition: \\{node.macroname} at pos {node.pos}. Reason: "
                                     f"Command arg group {{...}} did not contain a single macro node.")
                        is_simple_definition = False # Failed final check

                    if command_name and is_simple_definition:
                        # Final checks and storage
                        try:
                             # Need a simple way to stringify body for check
                             expanded_body_check = "".join(n.latex_verbatim() for n in body_nodelist if n).strip()
                        except Exception:
                             expanded_body_check = "[Error stringifying body]" # Fallback

                        if command_name == expanded_body_check:
                             logger.debug(f"SKIP Definition: \\{node.macroname} {command_name} at pos {node.pos}. Reason: Potentially recursive ('{expanded_body_check}').")
                        elif command_name in definitions_dict:
                            logger.info(f"Redefinition of {command_name} encountered near pos {node.pos}. Keeping previous.")
                        else:
                            logger.info(f"FOUND Definition: {command_name} -> {expanded_body_check}")
                            definitions_dict[command_name] = copy.deepcopy(body_nodelist)

        except AttributeError as ae:
             logger.error(f"Attribute error processing definition node \\{node.macroname} at pos {node.pos}: {ae}. Structure might be unexpected.", exc_info=True)
        except Exception as e:
            logger.error(f"General error processing definition node \\{node.macroname} at pos {node.pos}: {e}", exc_info=True)

        # If we processed this node (even if skipped), don't recurse into its args here
        if processed_node_flag:
             # Still need to recurse into the *body* if it exists, in case it contains defs
             if body_arg_group and hasattr(body_arg_group, 'nodelist'):
                 find_definitions_v2(body_arg_group.nodelist, definitions_dict, logger)
             return # Stop further recursion on this specific node

    # --- Recurse into children/arguments/body for non-definition nodes OR unprocessed def nodes ---
    # This ensures we find definitions nested inside other constructs or inside complex def args.
    if hasattr(node, 'nodelist') and node.nodelist is not None:
        find_definitions_v2(node.nodelist, definitions_dict, logger)
    if hasattr(node, 'nodeargd') and node.nodeargd is not None and hasattr(node.nodeargd, 'argnlist'):
         for arg_node in node.nodeargd.argnlist:
             if arg_node is not None: # Recurse into arguments
                  find_definitions_v2(arg_node, definitions_dict, logger)


def substitute_commands_v2(
    node_or_list: Optional[Union[LatexNodeType, V2NodelistType]],
    definitions_dict: Dict[str, V2NodelistType],
    logger: logging.Logger
) -> Tuple[Optional[Union[LatexNodeType, V2NodelistType]], bool]:
    """Recursively traverses the AST (list/nodes), substituting defined commands (v2).

    Returns a tuple: (new_node_or_list, substituted_flag).
    `new_node_or_list` is the modified node or list of nodes.
    `substituted_flag` is True if any substitution occurred in this branch.

    Args:
        node_or_list: The current node or list of nodes being traversed.
        definitions_dict: The dictionary of command definitions to apply.
        logger: A logging.Logger instance for outputting messages.

    Returns:
        A tuple containing the potentially modified node or list, and a boolean
        indicating if any substitution occurred.
    """
    if node_or_list is None:
        return None, False

    if isinstance(node_or_list, list): # Operate on Python lists
        new_list_items: V2NodelistType = []
        list_substituted = False
        for node in node_or_list:
            # Recursive call returns (new_item, item_substituted)
            # new_item could be a node, a list, or None
            new_node_or_list, substituted = substitute_commands_v2(node, definitions_dict, logger)
            if substituted:
                list_substituted = True # Flag that *something* changed in this list

            # Flatten results if a macro expanded into a list
            if isinstance(new_node_or_list, list):
                new_list_items.extend(new_node_or_list) # Add all items from the returned list
            elif new_node_or_list is not None:
                new_list_items.append(new_node_or_list) # Add the single returned node

        return new_list_items, list_substituted # Return the newly constructed list

    # --- Process single nodes ---
    node: LatexNodeType = node_or_list # Type assertion for clarity

    # --- Handle different node types ---
    if node.isNodeType(LatexCharsNode) or node.isNodeType(LatexCommentNode):
        # Leaf nodes, return copy (deepcopy just in case, though likely overkill for these)
        return copy.deepcopy(node), False

    elif node.isNodeType(LatexGroupNode):
        new_content_list, content_substituted = substitute_commands_v2(
            node.nodelist, definitions_dict, logger
        )
        # Use constructor directly
        new_node = LatexGroupNode(
            nodelist=new_content_list, # Expects a Python list
            parsing_state=node.parsing_state,
            delimiters=node.delimiters,
            pos=node.pos,
            len=node.len # v2 uses len
        )
        return new_node, content_substituted

    elif node.isNodeType(LatexEnvironmentNode):
        # Substitute in arguments first
        new_args_list = []
        args_substituted = False
        new_nodeargd = None
        if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and node.nodeargd.argnlist:
             for arg_node in node.nodeargd.argnlist:
                 new_arg, subst = substitute_commands_v2(arg_node, definitions_dict, logger)
                 if isinstance(new_arg, list):
                     logger.warning(f"Subst in env arg resulted in list near pos {arg_node.pos if arg_node else node.pos}. Using first node.")
                     new_args_list.append(new_arg[0] if new_arg else None)
                 else:
                     new_args_list.append(new_arg)
                 if subst: args_substituted = True
             # Rebuild ParsedMacroArgs
             try:
                 # Using deepcopy might be safer if ParsedMacroArgs has complex state
                 new_nodeargd = copy.deepcopy(node.nodeargd)
                 new_nodeargd.argnlist = new_args_list
             except Exception as e:
                 logger.error(f"Failed to reconstruct nodeargd for env {node.environmentname} at pos {node.pos}: {e}", exc_info=True)
                 new_nodeargd = node.nodeargd # Fallback

        # Substitute in body
        new_body_list, body_substituted = substitute_commands_v2(
            node.nodelist, definitions_dict, logger
        )
        # Use constructor directly
        new_node = LatexEnvironmentNode(
            environmentname=node.environmentname,
            nodelist=new_body_list, # Expects a Python list
            nodeargd=new_nodeargd,
            parsing_state=node.parsing_state,
            pos=node.pos,
            len=node.len
        )
        return new_node, (args_substituted or body_substituted)

    elif node.isNodeType(LatexMathNode):
        new_content_list, content_substituted = substitute_commands_v2(
            node.nodelist, definitions_dict, logger
        )
        new_node = LatexMathNode(
            nodelist=new_content_list,
            parsing_state=node.parsing_state,
            delimiters=node.delimiters,
            displaytype=node.displaytype,
            pos=node.pos,
            len=node.len
        )
        return new_node, content_substituted

    elif node.isNodeType(LatexSpecialsNode):
        # Substitute in arguments if any (similar logic to Environment)
        new_args_list = []
        args_substituted = False
        new_nodeargd = None
        if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and node.nodeargd.argnlist:
             for arg_node in node.nodeargd.argnlist:
                 new_arg, subst = substitute_commands_v2(arg_node, definitions_dict, logger)
                 if isinstance(new_arg, list):
                      logger.warning(f"Subst in specials arg resulted in list near pos {arg_node.pos if arg_node else node.pos}. Using first node.")
                      new_args_list.append(new_arg[0] if new_arg else None)
                 else:
                    new_args_list.append(new_arg)
                 if subst: args_substituted = True
             try:
                new_nodeargd = copy.deepcopy(node.nodeargd)
                new_nodeargd.argnlist = new_args_list
             except Exception as e:
                 logger.error(f"Failed to reconstruct nodeargd for specials {node.specials_chars} at pos {node.pos}: {e}", exc_info=True)
                 new_nodeargd = node.nodeargd # Fallback

        new_node = LatexSpecialsNode(
            specials_chars=node.specials_chars,
            nodeargd=new_nodeargd,
            parsing_state=node.parsing_state,
            pos=node.pos,
            len=node.len
        )
        return new_node, args_substituted

    elif node.isNodeType(LatexMacroNode):
        # Substitute in arguments first
        new_args_list = []
        args_substituted = False
        new_nodeargd = None
        if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and node.nodeargd.argnlist:
             for arg_node in node.nodeargd.argnlist:
                 new_arg, subst = substitute_commands_v2(arg_node, definitions_dict, logger)
                 if isinstance(new_arg, list):
                      logger.warning(f"Subst in macro arg resulted in list near pos {arg_node.pos if arg_node else node.pos}. Using first node.")
                      new_args_list.append(new_arg[0] if new_arg else None)
                 else:
                    new_args_list.append(new_arg)
                 if subst: args_substituted = True
             try:
                new_nodeargd = copy.deepcopy(node.nodeargd)
                new_nodeargd.argnlist = new_args_list
             except Exception as e:
                 logger.error(f"Failed to reconstruct nodeargd for macro \\{node.macroname} at pos {node.pos}: {e}", exc_info=True)
                 new_nodeargd = node.nodeargd # Fallback

        # Check if this macro is one we defined
        command_name = '\\' + node.macroname
        if command_name in definitions_dict:
            logger.debug(f"Substituting macro: {command_name} at pos {node.pos}")
            # Return a *copy* of the definition's list of nodes
            # The copy prevents issues if the same macro is used multiple times
            # The outer loop handles flattening this list if necessary
            return copy.deepcopy(definitions_dict[command_name]), True # Indicate substitution occurred
        else:
            # Not a defined command, reconstruct the node with potentially substituted args
            new_node = LatexMacroNode(
                macroname=node.macroname,
                nodeargd=new_nodeargd,
                macro_post_space=node.macro_post_space,
                parsing_state=node.parsing_state,
                pos=node.pos,
                len=node.len
            )
            # Substituted flag depends only on whether args were substituted
            return new_node, args_substituted

    else:
        # Fallback for unknown node types
        logger.warning(f"Unhandled node type during substitution: {type(node)}. Passing through.")
        return node, False


# --- Orchestrating Function ---

def apply_substitutions_iteratively(
    initial_nodelist: V2NodelistType,
    logger: Optional[logging.Logger] = None
) -> V2NodelistType:
    """Finds and applies simple command substitutions iteratively to an AST nodelist.

    This function orchestrates the process for pylatexenc v2.10 ASTs.
    It first scans the entire AST for simple, argument-less \newcommand and
    \DeclareMathOperator definitions. Then, it repeatedly traverses the AST,
    substituting occurrences of these defined commands with their definitions,
    until no more substitutions can be made in a pass or a maximum number
    of passes is reached.

    Args:
        initial_nodelist: The initial list of LatexNode objects representing the
                          parsed LaTeX document (output from pylatexenc v2.10 parser).
        logger: An optional logging.Logger instance. If None, a default logger
                for this module will be used.

    Returns:
        The final list of LatexNode objects representing the AST after all
        possible simple substitutions have been applied. This list can be passed
        to a subsequent AST processing/translation stage.
    """
    if logger is None:
        logger = logging.getLogger(__name__)
        # Basic config if run standalone, but usually configured by calling script
        if not logger.hasHandlers():
             logging.basicConfig(level=logging.INFO, format='%(name)s - %(levelname)s: %(message)s')

    if not initial_nodelist:
        logger.info("Initial nodelist is empty, no substitutions to apply.")
        return []

    # --- Step 1: Find Definitions ---
    logger.info("Finding command definitions...")
    definitions: Dict[str, V2NodelistType] = {}
    find_definitions_v2(initial_nodelist, definitions, logger)

    if not definitions:
        logger.info("No suitable command definitions found. Returning original nodelist.")
        return initial_nodelist

    logger.info(f"Found {len(definitions)} definitions. Starting iterative substitutions...")

    # --- Step 2: Iteratively Apply Substitutions ---
    current_nodelist = initial_nodelist # Start with the initial list
    for i in range(MAX_SUBSTITUTION_PASSES):
        pass_num = i + 1
        logger.info(f"--- Substitution Pass {pass_num} ---")

        # substitute_commands_v2 returns (list | node | None, bool)
        new_result, substituted_in_pass = substitute_commands_v2(
            current_nodelist, definitions, logger
        )

        # Ensure result is always a list for the next iteration/final result
        if isinstance(new_result, LatexNode):
             current_nodelist = [new_result]
        elif new_result is None:
             current_nodelist = []
        else:
             # Should be a list from the recursive call on the top-level list
             current_nodelist = new_result

        if not substituted_in_pass:
            logger.info(f"No substitutions made in pass {pass_num}. Finishing substitution phase.")
            break

        logger.info(f"Substitutions were made in pass {pass_num}.")
        if pass_num == MAX_SUBSTITUTION_PASSES:
            logger.warning(f"Reached maximum substitution passes ({MAX_SUBSTITUTION_PASSES}). "
                           "Expansion might be incomplete or there could be a dependency loop.")

    logger.info("Substitution phase complete.")
    return current_nodelist


# --- Example Usage (if run directly) ---
if __name__ == '__main__':
    # Configure logging for direct execution
    logging.basicConfig(level=logging.DEBUG, format='%(name)s - %(levelname)s: %(message)s')
    main_logger = logging.getLogger(__name__)

    # Example LaTeX with definitions and usage
    test_latex = r"""
\documentclass{article}
% Simple defs
\newcommand{\Greeting}{Hello}
\DeclareMathOperator{\MyOp}{Operator}
% Def using another def
\newcommand{\FullGreeting}{\Greeting, World!}
% Def with math inside
\DeclareMathOperator{\UnitVec}{\mathbf{e}}
% Skipped defs (due to complexity for this script)
\newcommand{\Add}[1]{#1+1}
\DeclareMathOperator*{\colim}{colim}

\begin{document}
Here is the greeting: \Greeting. And \MyOp.
The full message is \FullGreeting.
A unit vector is $\UnitVec_x$. Usage of Add: \Add{5}. Limit is $\colim X$.
\end{document}
"""
    main_logger.info("--- Running Direct Example ---")
    main_logger.info("Input LaTeX:\n%s", test_latex)

    # 1. Parse using LatexWalker (need instance for context)
    try:
        from pylatexenc.latexwalker import LatexWalker, get_default_latex_context_db
        lw = LatexWalker(test_latex, latex_context=get_default_latex_context_db())
        initial_ast, _, _ = lw.get_latex_nodes(pos=0)
        main_logger.info("--- Initial AST ---")
        # You could add a simple display function here if needed
        # print(initial_ast) # Raw list representation
    except Exception as e:
        main_logger.critical(f"Failed to parse example LaTeX: {e}", exc_info=True)
        sys.exit(1)

    # 2. Apply substitutions
    final_ast = apply_substitutions_iteratively(initial_ast, logger=main_logger)

    main_logger.info("--- Final AST (after substitutions) ---")
    # print(final_ast) # Raw list representation

    # 3. Show how to serialize back to TEXT (using a placeholder function)
    # In a real scenario, this final_ast would be passed to ast_to_lean.py
    def simple_ast_to_text(nodelist):
         # Basic text conversion - NOT robust like ast_to_lean.py
         text = ""
         for node in nodelist:
              if node is None: continue
              if isinstance(node, LatexCharsNode): text += node.chars
              elif isinstance(node, LatexGroupNode): text += simple_ast_to_text(node.nodelist)
              elif isinstance(node, LatexEnvironmentNode): text += simple_ast_to_text(node.nodelist)
              elif isinstance(node, LatexMathNode): text += simple_ast_to_text(node.nodelist)
              elif isinstance(node, LatexMacroNode): text += f"\\{node.macroname}" # Just show name
              # Ignore comments, specials for simplicity here
         return text

    final_text = simple_ast_to_text(final_ast)
    main_logger.info("--- Simplified Text from Final AST ---")
    main_logger.info(final_text)
    main_logger.info("--- Direct Example Complete ---")