# ast_to_lean.py

"""Translates a LaTeX AST (Abstract Syntax Tree) into a Lean-like format.

This module takes a nodelist representation of LaTeX code, as generated by
`latex_to_ast.parse_latex_to_ast_v210` (using pylatexenc v2.10), and
converts it into a text string resembling Lean syntax.

It applies substitutions for common LaTeX symbols, mathematical fonts
(\mathbb, \mathcal), handles specific environments (proofs, theorems, align),
and formats structures like fractions and scripts.

The main entry point is the `latex_to_lean_symbols` function.
"""

import logging
import sys
import re  # For whitespace cleanup
from typing import List, Optional, Dict, Union, TYPE_CHECKING

# --- Import Local Modules & Type Definitions ---
try:
    # Import the v2.10 parser and node types
    from latex_to_ast import (
        parse_latex_to_ast_v210,
        LatexNodeType, # Type alias for LatexNode
        LatexCharsNode, LatexMacroNode, LatexEnvironmentNode,
        LatexGroupNode, LatexMathNode, LatexCommentNode, LatexSpecialsNode
    )
    logging.debug("Successfully imported from latex_to_ast module.")
except ImportError as e:
    # Use basic print for critical errors before logging might be fully set up
    print(
        f"FATAL ERROR: Could not import from 'latex_to_ast.py'. "
        f"Ensure the file exists and pylatexenc v2.10 is installed. Error: {e}",
        file=sys.stderr
    )
    sys.exit(1)

try:
    # Import the translation mapping dictionaries
    from translation_maps import (
        SYMBOL_MAP, BLACKBOARD_BOLD_MAP, SCRIPT_MAP, SUBSCRIPT_MAP,
        DEFAULT_LATEX_ENV_TO_LEAN_KEYWORD # Keep default accessible if needed
    )
    logging.debug("Successfully imported from translation_maps module.")
except ImportError as e:
    print(
        f"FATAL ERROR: Could not import from 'translation_maps.py'. "
        f"Ensure the file exists. Error: {e}",
        file=sys.stderr
    )
    sys.exit(1)


# --- Logger Setup ---
# Configure logger for this module
logger = logging.getLogger(__name__)


# --- Helper Function ---
def _is_simple_content(content: str) -> bool:
    """Checks if content is 'simple'.

    Simple content is defined as a single alphanumeric character, a single known
    subscript character, or a sequence composed entirely of digits. This is used
    to determine if parentheses are needed around arguments (e.g., in fractions
    or scripts).

    Args:
        content: The string content to check.

    Returns:
        True if the content is considered simple, False otherwise.
    """
    if not isinstance(content, str):
        return False
    # Check if it's a single character that's alphanumeric OR a known subscript value
    is_single_simple_char = (
        len(content) == 1 and
        (content.isalnum() or content in SUBSCRIPT_MAP.values())
    )
    # Check if it consists only of digits
    is_all_digits = content.isdigit()

    return is_single_simple_char or is_all_digits


# --- AST Traversal and Translation Logic ---

def _translate_node_recursive(
    node: Optional[LatexNodeType],
    env_map: Dict[str, str]
) -> str:
    """Recursively traverses an AST node and translates it to a Lean-like string.

    This is the core workhorse function that handles different LaTeX node types
    and applies the relevant translation rules.

    Args:
        node: The LatexNode object (or None) to translate.
        env_map: The dictionary mapping LaTeX environment names to Lean keywords.
                 This map is passed down during recursion.

    Returns:
        The translated string representation of the node. Returns an empty
        string for None inputs or nodes that should be ignored (like comments).
    """
    if node is None:
        # Handles cases like missing optional arguments in the AST
        return ""

    # --- Handle Node Types ---

    if isinstance(node, LatexCharsNode):
        # Pass through regular character sequences directly
        return node.chars

    elif isinstance(node, LatexMacroNode):
        # Handle macro nodes (commands like \alpha, \frac, \mathbb, etc.)
        macro_name = node.macroname
        logger.debug("Translating macro: \\%s at pos %d", macro_name, node.pos)

        # --- Special case: \label ---
        # Labels are primarily for LaTeX internal referencing and usually not
        # translated directly into the Lean output text in this context.
        if macro_name == 'label':
            logger.debug("Skipping translation of '\\label' macro at pos %d.", node.pos)
            return "" # Produce no output for the label macro itself

        # 1. Check for direct symbol substitution (e.g., \alpha -> Î±)
        if macro_name in SYMBOL_MAP:
            unicode_symbol = SYMBOL_MAP[macro_name]
            # Warn if a symbol macro unexpectedly has arguments (except for sqrt)
            if node.nodeargd and node.nodeargd.argnlist and macro_name != 'sqrt':
                 logger.warning(
                     f"Symbol macro '\\{macro_name}' at pos {node.pos} "
                     f"has arguments, which is unusual. Ignoring arguments."
                 )
            logger.debug("Applied symbol map: \\%s -> %s", macro_name, unicode_symbol)
            return unicode_symbol

        # 2. Check for specific macro handlers (fractions, fonts, sqrt)
        elif macro_name in ['frac', 'dfrac', 'tfrac']: # Fractions
            if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and len(node.nodeargd.argnlist) == 2:
                num_node = node.nodeargd.argnlist[0]
                den_node = node.nodeargd.argnlist[1]
                # Recursively translate numerator and denominator
                num_str = _translate_node_recursive(num_node, env_map)
                den_str = _translate_node_recursive(den_node, env_map)

                # Remove outer group braces if present for simplicity check
                num_inner = num_str[1:-1] if isinstance(num_node, LatexGroupNode) and num_str.startswith('{') and num_str.endswith('}') else num_str
                den_inner = den_str[1:-1] if isinstance(den_node, LatexGroupNode) and den_str.startswith('{') and den_str.endswith('}') else den_str

                # Determine if parentheses are needed based on content complexity
                num_needs_paren = not _is_simple_content(num_inner) and not (num_inner.startswith('(') and num_inner.endswith(')'))
                den_needs_paren = not _is_simple_content(den_inner) and not (den_inner.startswith('(') and den_inner.endswith(')'))

                formatted_num = f"({num_inner})" if num_needs_paren else num_inner
                formatted_den = f"({den_inner})" if den_needs_paren else den_inner

                logger.debug("Translated fraction: (%s)/(%s)", formatted_num, formatted_den)
                return f"{formatted_num}/{formatted_den}"
            else:
                logger.warning(f"Fraction macro '\\{macro_name}' at pos {node.pos} did not have 2 arguments. Outputting literally.")
                # Fall through to fallback translation

        elif macro_name == 'sqrt':
             arg_node: Optional[LatexNodeType] = None
             # Logic to find the main argument node, handling pylatexenc v2 quirk
             if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and node.nodeargd.argnlist:
                 # Check for the specific v2.10 quirk where the first arg might be None
                 if len(node.nodeargd.argnlist) == 2 and node.nodeargd.argnlist[0] is None and node.nodeargd.argnlist[1] is not None:
                     logger.debug(f"Detected pylatexenc v2.10 '\\sqrt' quirk at pos {node.pos}. Using argnlist[1].")
                     arg_node = node.nodeargd.argnlist[1]
                 else:
                     # Otherwise, take the first non-None argument found
                     if len(node.nodeargd.argnlist) > 1:
                          logger.warning(
                              f"Parser provided {len(node.nodeargd.argnlist)} nodes for '\\sqrt' argument at pos {node.pos}. "
                              f"Using first non-None node found."
                          )
                     for potential_arg_node in node.nodeargd.argnlist:
                         if potential_arg_node is not None:
                             arg_node = potential_arg_node
                             break
                     if arg_node is None:
                         logger.error(f"Parser provided argument nodes for '\\sqrt' at pos {node.pos}, but all were None.")

             # Translate the found argument node
             if arg_node is not None:
                 translated_arg = _translate_node_recursive(arg_node, env_map)
                 arg_str = translated_arg if isinstance(translated_arg, str) else ""

                 if arg_str:
                     # Remove outer group braces if present for simplicity check
                     arg_inner = arg_str[1:-1] if isinstance(arg_node, LatexGroupNode) and arg_str.startswith('{') and arg_str.endswith('}') else arg_str
                     # Add parentheses if needed
                     arg_needs_paren = not _is_simple_content(arg_inner) and not (arg_inner.startswith('(') and arg_inner.endswith(')'))
                     formatted_arg = f"({arg_inner})" if arg_needs_paren else arg_inner
                     logger.debug("Translated sqrt: sqrt %s", formatted_arg)
                     return f"sqrt {formatted_arg}"
                 else:
                     logger.error(f"Failed to get valid string from argument node for '\\sqrt' at pos {node.pos}. Node: {arg_node}. Outputting fallback.")
             else:
                  logger.warning(f"Could not identify a valid argument node for '\\sqrt' at pos {node.pos}. Outputting fallback.")
             return f"\\sqrt{{?}}" # Fallback if no valid argument found

        elif macro_name == 'mathbb':
            # Handle \mathbb{...} for blackboard bold
            if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and len(node.nodeargd.argnlist) == 1:
                arg_node = node.nodeargd.argnlist[0]
                arg_str = _translate_node_recursive(arg_node, env_map)
                # Get inner content, removing group braces if necessary
                inner_arg = arg_str[1:-1] if isinstance(arg_node, LatexGroupNode) and arg_str.startswith('{') and arg_str.endswith('}') else arg_str
                # Apply character mapping
                translated = "".join(BLACKBOARD_BOLD_MAP.get(c, c) for c in inner_arg if isinstance(inner_arg, str))
                logger.debug("Translated mathbb: %s -> %s", inner_arg, translated)
                return translated
            else:
                logger.warning(f"Macro '\\mathbb' at pos {node.pos} did not have exactly 1 argument. Reconstructing literally.")
                # Fall through to fallback

        elif macro_name == 'mathcal':
            # Handle \mathcal{...} for script font
            if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and len(node.nodeargd.argnlist) == 1:
                arg_node = node.nodeargd.argnlist[0]
                arg_str = _translate_node_recursive(arg_node, env_map)
                inner_arg = arg_str[1:-1] if isinstance(arg_node, LatexGroupNode) and arg_str.startswith('{') and arg_str.endswith('}') else arg_str
                translated = "".join(SCRIPT_MAP.get(c, c) for c in inner_arg if isinstance(inner_arg, str))
                logger.debug("Translated mathcal: %s -> %s", inner_arg, translated)
                return translated
            else:
                logger.warning(f"Macro '\\mathcal' at pos {node.pos} did not have exactly 1 argument. Reconstructing literally.")
                # Fall through to fallback

        elif macro_name == 'mathbf':
             # Handle \mathbf{...} - usually just pass content through in Lean
             if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and len(node.nodeargd.argnlist) == 1:
                 arg_node = node.nodeargd.argnlist[0]
                 arg_str = _translate_node_recursive(arg_node, env_map)
                 if isinstance(arg_str, str):
                     # Remove outer group braces if present
                     inner_content = arg_str[1:-1] if isinstance(arg_node, LatexGroupNode) and arg_str.startswith('{') and arg_str.endswith('}') else arg_str
                     logger.debug("Translated mathbf: %s -> %s", arg_str, inner_content)
                     return inner_content
                 else:
                      logger.error(f"Expected string argument for '\\mathbf', got {type(arg_str)} ({repr(arg_str)}) at pos {node.pos}.")
                      return "{ERROR_BAD_ARG}"
             else:
                 logger.warning(f"Macro '\\mathbf' at pos {node.pos} did not have exactly 1 argument. Reconstructing literally.")
                 # Fall through to fallback

        # 3. Fallback for other unhandled macros
        else:
            # For macros not explicitly handled, translate their arguments' content
            # and concatenate them. This might lose the macro's semantic meaning
            # but preserves the content.
            logger.info(f"Unhandled macro '\\{macro_name}' encountered at pos {node.pos}. Translating argument content only.")
            content_parts = []
            if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and node.nodeargd.argnlist:
                for i, arg_node in enumerate(node.nodeargd.argnlist):
                    translated_arg = _translate_node_recursive(arg_node, env_map)
                    if translated_arg is not None:
                         # Remove outer group braces if the argument was a group
                         if isinstance(arg_node, LatexGroupNode) and translated_arg.startswith('{') and translated_arg.endswith('}'):
                             content_parts.append(translated_arg[1:-1])
                         else:
                             content_parts.append(translated_arg)
            return "".join(content_parts)


    elif isinstance(node, LatexGroupNode):
        # Handle braced groups {...} or bracketed groups [...] etc.
        # Recursively translate the content within the group.
        content = "".join(_translate_node_recursive(n, env_map) for n in node.nodelist)
        start_delim, end_delim = node.delimiters if node.delimiters else ('{', '}') # Default to braces

        # Check if we should strip the delimiters:
        # Keep delimiters unless it's standard braces {} wrapping simple content.
        is_braces = (start_delim == '{' and end_delim == '}')
        if is_braces and _is_simple_content(content):
            logger.debug("Stripping braces for simple group content: '%s'", content)
            return content
        else:
            logger.debug("Keeping delimiters '%s%s' for group content: '%s'", start_delim, end_delim, content)
            return f"{start_delim}{content}{end_delim}"

    elif isinstance(node, LatexEnvironmentNode):
        # Handle environments like \begin{theorem}...\end{theorem}
        env_name = node.environmentname
        logger.debug("Translating environment: '%s' at pos %d", env_name, node.pos)

        # --- align/align* environments ---
        # Special handling for math alignment environments
        if env_name in ['align', 'align*']:
             body_parts = []
             current_line_nodes = []
             # Iterate through nodes in the environment body
             for body_node in node.nodelist:
                  # Line breaks (\\) finalize the current line
                  if isinstance(body_node, LatexMacroNode) and body_node.macroname == '\\':
                      line_str = "".join(_translate_node_recursive(n, env_map) for n in current_line_nodes).strip()
                      if line_str: body_parts.append(line_str)
                      current_line_nodes = [] # Reset for next line
                  # Alignment points (&) are usually ignored in Lean output
                  elif isinstance(body_node, LatexSpecialsNode) and body_node.specials_chars == '&':
                      continue # Skip alignment markers
                  # Comments are ignored
                  elif isinstance(body_node, LatexCommentNode):
                      continue
                  # Accumulate other nodes for the current line
                  else:
                      current_line_nodes.append(body_node)
             # Process the last line
             last_line_content = "".join(_translate_node_recursive(n, env_map) for n in current_line_nodes).strip()
             if last_line_content: body_parts.append(last_line_content)
             # Join lines with newline characters
             processed_body = "\n".join(part for part in body_parts if part)
             # Add surrounding newlines for block formatting
             logger.debug("Translated align environment body:\n%s", processed_body)
             return f"\n{processed_body}\n" if processed_body else ""

        # --- Keyword environments (theorem, lemma, def, etc.) ---
        # Check if the environment name is in our mapping (passed via env_map)
        elif env_name in env_map:
             lean_keyword = env_map[env_name]
             item_label = "" # Optional label/name for the theorem/lemma
             nodelist_offset = 0 # Index to start processing body content

             # Check for optional argument [...] after \begin{env}
             # This often contains a custom name or description.
             optional_arg_label = ""
             if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and node.nodeargd.argnlist:
                 optional_arg_node = node.nodeargd.argnlist[0]
                 if optional_arg_node: # If optional arg was provided
                     translated_arg = _translate_node_recursive(optional_arg_node, env_map)
                     # Extract content, removing brackets if present
                     if isinstance(optional_arg_node, LatexGroupNode) and getattr(optional_arg_node, 'delimiters', None) == ('[', ']'):
                         optional_arg_label = translated_arg[1:-1].strip()
                     else: # Should be brackets, but handle defensively
                         optional_arg_label = translated_arg.strip()

             # Check for \label{...} command at the very beginning of the environment body
             # This is often used for referencing theorems.
             label_macro_label = ""
             if node.nodelist: # Check if body is not empty
                 first_node = node.nodelist[0]
                 if isinstance(first_node, LatexMacroNode) and first_node.macroname == 'label':
                     # Extract the label string from the \label command's argument
                     if first_node.nodeargd and hasattr(first_node.nodeargd, 'argnlist') and first_node.nodeargd.argnlist:
                         label_arg_node = first_node.nodeargd.argnlist[0]
                         if label_arg_node:
                             label_content = _translate_node_recursive(label_arg_node, env_map)
                             # Remove braces if present
                             if isinstance(label_arg_node, LatexGroupNode) and label_content.startswith('{') and label_content.endswith('}'):
                                 label_macro_label = label_content[1:-1].strip()
                             else:
                                 label_macro_label = label_content.strip()
                             # If we found a label, skip this node when processing the body
                             if label_macro_label:
                                 nodelist_offset = 1
                                 logger.debug("Found label '%s' inside environment '%s'", label_macro_label, env_name)

             # Prioritize \label if present, otherwise use the optional arg [...]
             item_label = label_macro_label if label_macro_label else optional_arg_label
             label_part = f" {item_label}" if item_label else "" # Add space only if label exists

             # Translate the rest of the environment body
             body_nodes = node.nodelist[nodelist_offset:]
             body = "".join(_translate_node_recursive(n, env_map) for n in body_nodes).strip()

             # Format with indentation for Lean
             indented_body = "\n".join("  " + line for line in body.split('\n') if line.strip())
             separator = "\n" if indented_body else "" # Add newline only if body is non-empty

             logger.debug("Translated '%s' env as '%s%s'", env_name, lean_keyword, label_part)
             return f"{lean_keyword}{label_part} :{separator}{indented_body}\n"

        # --- Proof environment ---
        elif env_name == 'proof':
             # Translate body content
             body = "".join(_translate_node_recursive(n, env_map) for n in node.nodelist).strip()
             # Indent body
             indented_body = "\n".join("  " + line for line in body.split('\n') if line.strip())
             separator = "\n" if indented_body else "" # Add newline only if body is non-empty
             logger.debug("Translated proof environment.")
             return f"proof{separator}{indented_body}\nend\n" # Use Lean's 'end' for proofs

        # --- Fallback for other unhandled environments ---
        else:
             # If the environment isn't specifically handled, translate its content
             # and wrap it loosely, indicating the original environment name.
             # This prevents content loss but might not be valid Lean.
             logger.info(f"Unhandled environment '{env_name}' encountered at pos {node.pos}. Translating content only.")
             args_str = ""
             # Translate arguments if any
             if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and node.nodeargd.argnlist:
                 translated_args = [_translate_node_recursive(arg, env_map) for arg in node.nodeargd.argnlist]
                 # Reconstruct argument string representation (basic)
                 args_str = "".join([
                     arg if isinstance(arg_node, LatexGroupNode) else f"{{{arg}}}"
                     for arg, arg_node in zip(translated_args, node.nodeargd.argnlist) if arg is not None
                 ])
             # Translate body
             body = "".join(_translate_node_recursive(n, env_map) for n in node.nodelist)
             # Consider just returning the body for unknown environments? Or wrap it?
             # Let's just return the body to avoid adding LaTeX back in.
             # return f"\\begin{{{env_name}}}{args_str}\n{body}\n\\end{{{env_name}}}" # Old fallback
             logger.debug("Returning only body content for unhandled env '%s'", env_name)
             return body


    elif isinstance(node, LatexMathNode):
        # Handle math mode blocks ($...$, \[...\])
        # Translate the content inside the math block recursively
        content = "".join(_translate_node_recursive(n, env_map) for n in node.nodelist)
        # Basic cleanup of excessive whitespace within math content
        cleaned_content = re.sub(r'\s+', ' ', content).strip()

        # Format based on display type (inline vs display)
        # For Lean, we typically just include the translated math content directly.
        if node.displaytype == 'inline':
            logger.debug("Translated inline math: '%s'", cleaned_content)
            return cleaned_content # No surrounding delimiters needed usually
        elif node.displaytype == 'display':
            # Add surrounding newlines for display math for better formatting
            logger.debug("Translated display math:\n%s", cleaned_content)
            return f"\n{cleaned_content}\n" if cleaned_content else ""
        else:
             # Handle unknown math types defensively
             logger.warning(f"Unknown math display type '{node.displaytype}' at pos {node.pos}. Processing content without delimiters.")
             return cleaned_content

    elif isinstance(node, LatexCommentNode):
        # Comments are typically ignored in the final output
        logger.debug("Ignoring comment at pos %d: %%%s", node.pos, node.comment)
        return ""

    elif isinstance(node, LatexSpecialsNode):
        # Handle special LaTeX characters/sequences like _, ^, &, % etc.
        specials = node.specials_chars
        logger.debug("Translating specials '%s' at pos %d", specials, node.pos)

        # --- Handle Subscripts (_) ---
        if specials == '_':
            # Expects one argument (the subscript content)
            if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and node.nodeargd.argnlist:
                arg_node = node.nodeargd.argnlist[0]
                if arg_node is not None:
                    arg_str = _translate_node_recursive(arg_node, env_map)
                    # Remove outer group braces if present
                    inner_arg_str = arg_str[1:-1] if isinstance(arg_node, LatexGroupNode) and arg_str.startswith('{') and arg_str.endswith('}') else arg_str

                    # Attempt to convert to Unicode subscript characters
                    subscript_chars = []
                    possible_to_convert = True
                    if not inner_arg_str: # Handle empty subscript _{}
                        possible_to_convert = False
                        logger.warning(f"Empty subscript _{{}} found near pos {node.pos}. Using ASCII '_' fallback.")
                        return "_" # Fallback to ASCII underscore

                    for char in inner_arg_str:
                        if char in SUBSCRIPT_MAP:
                            subscript_chars.append(SUBSCRIPT_MAP[char])
                        else:
                            possible_to_convert = False
                            logger.debug(f"Cannot convert char '{char}' to subscript near pos {node.pos}. Using fallback.")
                            break # Stop conversion attempt

                    if possible_to_convert:
                        # Successfully converted all chars to Unicode subscripts
                        unicode_sub = "".join(subscript_chars)
                        logger.debug("Translated subscript: _%s -> %s", inner_arg_str, unicode_sub)
                        return unicode_sub
                    else:
                        # Could not convert all chars, revert to fallback LaTeX-like syntax
                        # Determine if braces are needed in the fallback
                        needs_braces = (
                            not _is_simple_content(inner_arg_str) and
                            not (inner_arg_str.startswith('(') and inner_arg_str.endswith(')'))
                        )
                        # Also add braces if the original node wasn't a group but content is multi-char
                        if not isinstance(arg_node, LatexGroupNode) and len(inner_arg_str) > 1:
                             needs_braces = True

                        fallback_sub = f"_{{{inner_arg_str}}}" if needs_braces else f"_{inner_arg_str}"
                        logger.debug("Using fallback for subscript: %s", fallback_sub)
                        return fallback_sub
                else:
                     # Argument node was None (shouldn't happen for mandatory arg like _)
                     logger.warning(f"Subscript '_' at pos {node.pos} has None argument. Reconstructing literally.")
                     return "_"
            else:
                # No argument list found for subscript
                logger.warning(f"Subscript '_' at pos {node.pos} has no argument list. Reconstructing literally.")
                return "_"

        # --- Handle Superscripts (^) ---
        elif specials == '^':
             # Translate the superscript argument
             args_str = ""
             arg_content_for_paren_check = ""
             if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and node.nodeargd.argnlist:
                  arg_node = node.nodeargd.argnlist[0]
                  if arg_node is not None:
                     original_node_type_was_group = isinstance(arg_node, LatexGroupNode)
                     translated_arg = _translate_node_recursive(arg_node, env_map)
                     args_str = translated_arg
                     # Get inner content for simplicity check
                     arg_content_for_paren_check = args_str[1:-1] if original_node_type_was_group and args_str.startswith('{') and args_str.endswith('}') else args_str

             # Add parentheses if the content isn't simple
             needs_paren = not _is_simple_content(arg_content_for_paren_check) and not (arg_content_for_paren_check.startswith('(') and arg_content_for_paren_check.endswith(')'))
             # Format with parentheses if needed
             final_arg_str = f"({arg_content_for_paren_check})" if needs_paren else args_str
             logger.debug("Translated superscript: ^%s", final_arg_str)
             return f"^{final_arg_str}" # Use standard ^ for superscript

        # --- Handle other special characters (like escaped chars \%) ---
        # This handles sequences recognized as 'specials' by pylatexenc's default
        # context, which often includes escaped symbols like \% or alignment tabs &.
        else:
             # Translate arguments if any (rare for basic specials)
             args_str = ""
             if node.nodeargd and hasattr(node.nodeargd, 'argnlist') and node.nodeargd.argnlist:
                  translated_args = [_translate_node_recursive(arg, env_map) for arg in node.nodeargd.argnlist]
                  args_str = "".join(translated_args)

             # Specific handling for escaped symbols -> return the symbol itself
             if specials == '\\' and args_str in ['&', '%', '$', '#', '_', '{', '}']:
                  logger.debug("Translated escaped special: \\%s -> %s", args_str, args_str)
                  return args_str
             # For other specials (like ~, &), decide on representation.
             # Often, they might be ignored or replaced with space/nothing depending on context.
             # Let's default to ignoring them for now, logging a warning.
             logger.warning(f"Unhandled specials node '{specials}' with args '{args_str}' at pos {node.pos}. Ignoring.")
             return ""
             # Alternative: return f"{specials}{args_str}" # Reproduce literally


    else: # Fallback for any unexpected or unhandled node types
        node_info = f"type={type(node)}"
        try: # Add position info if available
             node_info += f", pos={node.pos}"
        except AttributeError: pass
        logger.warning(f"Unhandled node encountered during translation: {node_info}. Skipping.")
        return ""

# --- Main Translation Function ---
def latex_to_lean_symbols(
    environment_map: Dict[str, str],                  # Env map is required
    nodelist_in: Optional[List[LatexNodeType]] = None, # Optional pre-parsed list
    latex_string_for_parsing: Optional[str] = None,  # Optional string input
    tolerant_parsing: bool = False
) -> Optional[str]:
    """Parses LaTeX (if needed) and translates the AST using symbol/env substitutions.

    Can accept either a LaTeX string (which it will parse using the v2.10 parser)
    or a pre-parsed nodelist (AST). It then traverses the AST, applying translation
    rules defined in `_translate_node_recursive` and using the provided
    `environment_map`.

    Args:
        environment_map: Dictionary mapping LaTeX environment names to Lean keywords.
        nodelist_in: An optional pre-parsed list of LatexNode objects (AST).
                     If provided, parsing is skipped.
        latex_string_for_parsing: The LaTeX string to parse, used only if
                                  nodelist_in is None.
        tolerant_parsing: Flag passed to the parser if latex_string_for_parsing
                          is used.

    Returns:
        The translated string in a Lean-like format, or None if a critical
        error occurred during parsing or translation.
    """
    ast_nodelist: Optional[List[LatexNodeType]] = None # Initialize

    # --- Decide whether to parse or use provided nodelist ---
    if nodelist_in is not None:
        ast_nodelist = nodelist_in
        logger.info("Using pre-parsed AST nodelist provided via nodelist_in.")
    elif latex_string_for_parsing is not None:
        logger.info("Parsing LaTeX string provided via latex_string_for_parsing...")
        # Call the v2.10 parser from latex_to_ast
        ast_nodelist = parse_latex_to_ast_v210(latex_string_for_parsing, tolerant_parsing=tolerant_parsing)
        if ast_nodelist is None:
            logger.error("Failed to parse LaTeX input during translation step. Aborting.")
            return None
        if not ast_nodelist:
            # Handle case where parsing succeeds but returns empty list
            logger.info("Input parsed to an empty AST. Returning empty string.")
            return ""
        logger.info("Parsing successful within translation step.")
    else:
         # Error if neither input method is provided
         logger.error("latex_to_lean_symbols called without latex_string_for_parsing or nodelist_in.")
         return None

    # --- Translate the determined AST ---
    logger.info("Starting AST traversal and translation...")
    try:
        # Translate each top-level node using the recursive helper
        translated_parts = [_translate_node_recursive(node, environment_map) for node in ast_nodelist]
    except Exception as e:
         # Catch errors during the recursive translation process
         logger.exception(f"Error during recursive node translation: {e}")
         return None # Abort on error during traversal

    # --- Final cleanup ---
    logger.info("Performing final string cleanup...")
    final_string = "".join(translated_parts)
    # Consolidate multiple blank lines into single blank lines
    final_string = re.sub(r'\n\s*\n+', '\n\n', final_string)
    # Remove leading/trailing whitespace from the entire result
    final_string = final_string.strip()

    logger.info("Translation finished.")
    return final_string